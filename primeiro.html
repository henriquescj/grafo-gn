<!-- START SIGMA IMPORTS -->
<script src="js/script.js"></script>
<!-- END SIGMA IMPORTS -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="/css/style.css">
<script>
// declarao de algumas variaveis necessarias
var blue = "rgb(0,49,61)",
    red = "rgb(112,0,13)",
    yellow = "rgb(203,154,0)",
    g;
</script>
<!--  -->
<script src="nodes.js"></script>
<script src="edges.js"></script>
<script src="words.js"></script>
    <section class="grafo-gn">
        <style>
        </style>
        <div id="graph-container"></div>
        <div id="aparecer"></div>
        <div class="select-word">
            <div class="grafo-word filter-word" data-value="aborto">Aborto</div>
            <div class="grafo-word filter-word" data-value="">escola</div>
            <div class="grafo-word filter-word" data-value="">escolha</div>
            <div class="grafo-word filter-word" data-value="">nascer</div>
            <div class="grafo-word filter-word" data-value="">aborto</div>
            <div class="grafo-word filter-word" data-value="">certo</div>
            <div class="grafo-word filter-word" data-value="">errado</div>
            <div class="grafo-word filter-word" data-value="carencia">carencia</div>
            <div class="grafo-word filter-word" data-value="poder">poder</div>
        </div>
    </section>
<script>
    var i, s;

    // Add a method to the graph model that returns an
    // object with every neighbors of a node inside:
    sigma.classes.graph.addMethod('neighbors', function(nodeId) {
        var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

        for (k in index)
            neighbors[k] = this.nodesIndex[k];

        return neighbors;
    });

    // Instantiate sigma:
    s = new sigma({
        graph: g,
        renderer: {
            // IMPORTANT:
            // This works only with the canvas renderer, so the
            // renderer type set as "canvas" is necessary here.
            container: document.getElementById('graph-container'),
            type: 'canvas',
        },
        settings: {
            minNodeSize: 8,
            maxNodeSize: 16,
            minEdgeSize: 2,
            maxEdgeSize: 2,
            singleHover: true,
            drawLabels: false,
            drawEdgeLabels: false,
            enableEdgeHovering: false,
            enableHovering: false,
            // scalingMode: "outside",
        },
    });

    // We first need to save the original colors of our
    // nodes and edges, like this:
    s.graph.nodes().forEach(function(n) {
        n.originalColor = n.color;
    });
    s.graph.edges().forEach(function(e) {
        e.originalColor = e.color;
    });

    // When a node is clicked, we check for each node
    // if it is a neighbor of the clicked one. If not,
    // we set its color as grey, and else, it takes its
    // original color.
    // We do the same for the edges, and we only keep
    // edges that have both extremities colored.
    s.bind('clickNode', function(e) {
        var nodeId = e.data.node.id,
            toKeep = s.graph.neighbors(nodeId);
        toKeep[nodeId] = e.data.node;

        s.graph.nodes().forEach(function(n) {
            if (toKeep[n.id])
                n.color = n.originalColor;
            else
                n.color = '#efefef';
        });

        s.graph.edges().forEach(function(e) {
            if (toKeep[e.source] && toKeep[e.target]) {
                e.color = e.originalColor;
                e.type = "arrow";
            }
            else
                e.color = '#efefef';
        });

        // Since the data has been modified, we need to
        // call the refresh method to make the colors
        // update effective.
        s.refresh();
    });

    s.bind('overNode', function(e) {
        var y = e.data.node["renderer1:y"] - 80;
        var x = e.data.node["renderer1:x"] + 30;
        var novaDiv = "";

        novaDiv +='<div class="box-infos" style="position: absolute; top:' + y + 'px; left: ' + x + 'px;">';
          novaDiv +='<div class="talk-bubble tri-right btm-left">';
            novaDiv +='<div class="talktext d-flex">';
              novaDiv +='<img class="img-perfil bg-img" src=" ' + e.data.node.img + ' " alt=" ' + e.data.node.label + ' ">';
              novaDiv +='<a class="link-perfil" href=" ' + e.data.node.link + ' " target="_blank"><p class="ml-2"> '+ e.data.node.label +' </p></a>';
            novaDiv +='</div>';
          novaDiv +='</div>';
        novaDiv +='</div>';

        $("#aparecer").html(novaDiv);
        // setTimeout(function(){ $("#aparecer").html(novaDiv); }, 200);
    });

    s.bind('outNode', function (e) {
        // $("#aparecer").empty();
        setTimeout(function(){ $("#aparecer").empty(); }, 3000);
    });

    // When the stage is clicked, we just color each
    // node and edge with its original color.
    s.bind('clickStage', function(e) {
        s.graph.nodes().forEach(function(n) {
            n.color = n.originalColor;
        });

        s.graph.edges().forEach(function(e) {
            e.color = e.originalColor;
            e.type = "dash";
        });
        // $("#aparecer").empty();

        // Same as in the previous event:
        s.refresh();
    });

    // filtro de palavras
    $(".filter-word").click(function () {
        var posicao = $(this).data('value');
        var ids = words[posicao];
        s.graph.edges().forEach(function(e) {
            e.color = '#efefef';
        });
        s.graph.nodes().forEach(function(node) {
            if ($.inArray(node.id, ids) > -1){
                node.color = node.originalColor;
            }
            else
                node.color = '#efefef';
        });
        s.refresh();
    });

    // Configure the noverlap layout:
    var noverlapListener = s.configNoverlap({
        nodeMargin: 0.1,
        scaleNodes: 1.05,
        gridSize: 75,
        easing: 'quadraticInOut', // animation transition function
        duration: 100   // animation duration. Long here for the purposes of this example only
    });
    // Bind the events:
    noverlapListener.bind('start stop interpolate', function(e) {
        console.log(e.type);
        if(e.type === 'start') {
            console.time('noverlap');
        }
        if(e.type === 'interpolate') {
            console.timeEnd('noverlap');
        }
    });
    // Start the layout:
    s.startNoverlap();
</script>
